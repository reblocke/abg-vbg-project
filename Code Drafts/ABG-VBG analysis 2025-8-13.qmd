---
title: "ABG-VBG Analysis"
author: "Brian Locke, Anila Mehta"
format: html
editor: visual
---

## Data Pre-processing

This code pulls in the master database (a STATA file) and does some initial cleaning - this will only need to be run once, and then the data can be accessed in the usual way.

**BL 7/26/25** - new: I augmented this code block to check for all needed packages, and important everything up front

```{r}
# Consolidated package management ------------------------------------------------
required_pkgs <- c(
  "WeightIt", "broom", "cobalt", "codebookr", "dplyr", "flextable", "parallel",
  "gbm", "ggplot2", "gt", "gtsummary", "haven", "labelled", "scales",
  "modelsummary", "officer", "patchwork", "rms", "survey", "tibble", "lubridate", "sensitivitymw"
)

# Install any missing packages (with dependencies)
missing_pkgs <- setdiff(required_pkgs, rownames(installed.packages()))
if (length(missing_pkgs)) {
  install.packages(missing_pkgs, dependencies = TRUE)
}

# Load (or attach) all required packages
invisible(lapply(required_pkgs, require, character.only = TRUE))
```

Converts the data from a STATA format to rdata if the rdata file does not exist. If it does already exist, it just loads that.

```{r}
data_dir_name <- '/Users/reblocke/Research/abg-vbg-project/data' # 'data/' this is changed from just
rdata_file <- file.path(data_dir_name, "full_trinetx.rdata")
stata_file <- file.path(data_dir_name, "full_db.dta")

if (!dir.exists(data_dir_name)) {
  dir.create(data_dir_name)
  message("Directory 'data' created.")
} else {
  message("Directory 'data' already exists.")
}

if (file.exists(rdata_file)) {
  load(rdata_file)
  message("Loaded existing dataset from 'full_trinetx.rdata'.")
} else {
  message("RData file not found. Reading Stata dataset...")
  stata_data <- read_dta(stata_file)
  
  message("Extracting variable labels...")
  var_label(stata_data)

  message("Extracting value labels...")
  sapply(stata_data, function(x) if (is.labelled(x)) val_labels(x))

  save(stata_data, file = rdata_file)
  message("Dataset saved as 'full_trinetx.rdata'.")

  load(rdata_file)
  message("Loaded newly saved dataset from 'full_trinetx.rdata'.")
}
```

Creating subset_data

```{r}
set.seed(123)
rows_to_keep <- round(nrow(stata_data) * 1.0) # 1.0 = keep all the data - lessen to make a smaller subset.
subset_data <- stata_data[sample(nrow(stata_data), rows_to_keep), ]
dim(subset_data)
```

Generating Codebook for the Full Dataset

```{r}
message("Generating codebook for the dataset...")
study_codebook <- codebookr::codebook(
  stata_data,
  title = "Full TrinetX",
  subtitle = "Dataset Documentation",
  description = "This dataset contains patient-level records from the TrinetX database. 
                 It has been processed and converted from the original Stata file."
)
codebook_file <- file.path(data_dir_name, "codebookr.docx")
print(study_codebook, codebook_file)
message("Codebook saved as 'codebookr.docx' in the data directory.")
```

New Variable - Death at 60 days

```{r}
subset_data <- subset_data %>%
  mutate(
    ## 1. Did the patient die?
    died = if_else(!is.na(death_date), 1L, 0L),

    ## 2. Absolute death date (if death_date is an offset)
    death_abs = if_else(!is.na(death_date),
                        encounter_date + death_date,
                        as.Date(NA)),

    ## 3. Year month (YM) for encounter and death
    enc_ym   = floor_date(encounter_date, unit = "month"),
    death_ym = floor_date(death_abs      , unit = "month"),

    ## 4. Reference censoring date: 1 Jun 2024
    ref_ym = ymd("2024-06-01"),

    ## 5. Months from encounter to death or censoring
    months_death_or_cens = case_when(
      !is.na(death_ym) ~ interval(enc_ym, death_ym) %/% months(1),
      TRUE             ~ interval(enc_ym, ref_ym)   %/% months(1)
    ),

    ## 6. Remove impossible values
    months_death_or_cens = if_else(
      months_death_or_cens < 0 | months_death_or_cens > 16,
      NA_integer_, months_death_or_cens
    ),

    ## 7. Death within one or two months
    died_1mo = if_else(died == 1 & months_death_or_cens <  1, 1L, 0L),
    died_2mo = if_else(died == 1 & months_death_or_cens <= 1, 1L, 0L),

    ## 8. Month of death (missing if censored)
    death_time = if_else(died == 1, months_death_or_cens, NA_integer_),

    ## 9. Death within 60 days (new variable)
    death_60d = if_else(died == 1 & death_abs <= (encounter_date + days(60)), 1L, 0L)
  ) %>%
  select(-enc_ym, -death_ym)

subset_data <- subset_data %>%
  mutate(
    death_60d = if_else(died == 1 & death_abs <= (encounter_date + days(60)), 1L, 0L)
  )

```

```{r}
table(subset_data$death_60d, useNA = "ifany")
prop.table(table(subset_data$death_60d, useNA = "ifany"))
summary(subset_data$death_60d)
```

Table 1A and 1B:

adjusted version of the same table

-   [ ] TODO: I'd use race_ethnicity rather than just race. I updated this in the regression and IPW but haven't yet in the table.

-   [ ] TODO: need to add location (= region in the US) to this.

```{r}
# ---------------------------------------------------------------------------
# Robust derivation of analysis variables + helper for Table 1 production
# ---------------------------------------------------------------------------

# helper: label binary 0/1 → "No"/"Yes"
bin_lab <- function(x) factor(x, levels = c(0, 1), labels = c("No", "Yes"))

subset_data <- subset_data %>% 
  mutate(
    ## ensure 0/1 numerics (avoids factor‑level coercion)
    across(c(has_abg, has_vbg, hypercap_on_abg, hypercap_on_vbg),
           ~ as.numeric(as.character(.))),
    
    ## derive ABG / VBG hypercapnia groups
    abg_group
    = case_when(
      has_abg == 0                         ~ "No ABG",
      has_abg == 1 & hypercap_on_abg == 0  ~ "ABG_NoHypercapnia",
      has_abg == 1 & hypercap_on_abg == 1  ~ "ABG_Hypercapnia",
      TRUE                                 ~ "Missing"
    ),
    vbg_group = case_when(
      has_vbg == 0                         ~ "No VBG",
      has_vbg == 1 & hypercap_on_vbg == 0  ~ "VBG_NoHypercapnia",
      has_vbg == 1 & hypercap_on_vbg == 1  ~ "VBG_Hypercapnia",
      TRUE                                 ~ "Missing"
    ),
    
    ## factorise groups with explicit NA/Missing level
    abg_group = factor(
      abg_group,
      levels = c("No ABG", "ABG_NoHypercapnia", "ABG_Hypercapnia", "Missing")
    ),
    vbg_group = factor(
      vbg_group,
      levels = c("No VBG", "VBG_NoHypercapnia", "VBG_Hypercapnia", "Missing")
    ),
    
    ## labelled covariates
    sex_label      = factor(sex, levels = c(0, 1), labels = c("Female", "Male")),
    race_label     = factor(
      race,
      levels = c(0, 1, 2, 3, 4, 5),
      labels = c("White", "Black or African American", "Unknown",
                 "Asian", "American Indian", "Pacific Islander")
    ),
    osa_label      = bin_lab(osa),
    asthma_label   = bin_lab(asthma),
    copd_label     = bin_lab(copd),
    chf_label      = bin_lab(chf),
    nmd_label      = bin_lab(nmd),
    phtn_label     = bin_lab(phtn),
    ckd_label      = bin_lab(ckd),
    diabetes_label = bin_lab(dm)
  )

# variables to summarise
vars <- c(
  "age_at_encounter", "curr_bmi", "sex_label", "race_label",
  "osa_label", "asthma_label", "copd_label", "chf_label", "nmd_label",
  "phtn_label", "ckd_label", "diabetes_label", "vbg_co2", "paco2"
)

# Table 1 constructor
make_table1 <- function(data, group_var, caption = "") {
  group_sym <- rlang::sym(group_var)

  data %>% 
    filter(!is.na(!!group_sym),                   # drop explicit NA
           !!group_sym != "Missing") %>%          # drop “Missing” cohort
    droplevels() %>%                              # trim empty factor levels
    select(all_of(c(group_var, vars))) %>% 
    gtsummary::tbl_summary(
      by   = !!group_sym,
      type = list(sex_label ~ "categorical"),
      statistic = list(
        gtsummary::all_continuous()  ~ "{mean} ± {sd}; {N_miss}/{N_obs} missing ({p_miss}%)",
        gtsummary::all_categorical() ~ "{n} ({p}%)"
      ),
      digits   = list(gtsummary::all_continuous() ~ 1),
      missing  = "no"                               # no gtsummary missing column/row
    ) %>% 
    gtsummary::modify_header(label = "**Variable**") %>% 
    gtsummary::modify_caption(caption)
}

# build tables
table1A <- make_table1(subset_data, "abg_group", caption = "Table 1A: ABG cohorts")
table1B <- make_table1(subset_data, "vbg_group", caption = "Table 1B: VBG cohorts")

table1A
table1B
```

Generating Word Doc for Table 1A & 1B

```{r}
ft_table1A <- as_flex_table(table1A)
ft_table1B <- as_flex_table(table1B)

doc <- read_docx() %>%
  body_add_par("Table 1A. Baseline Characteristics by ABG Group", style = "heading 1") %>%
  body_add_flextable(ft_table1A) %>%
  body_add_par("Table 1B. Baseline Characteristics by VBG Group", style = "heading 1") %>%
  body_add_flextable(ft_table1B)

print(doc, target = "Table1_ABG_VBG.docx")

```

**Unweighted, Hypercapnia (binary yes/no) Simple (1 predictor) Regressions:**

Unweighted, ABG Group: hypercapnia treated as a binary (yes/no) predictor

```{r}
logit_intubated_abg <- glm(imv_proc ~ hypercap_on_abg, data = subset_data, family = binomial)
summary(logit_intubated_abg)

tidy(logit_intubated_abg,
     exponentiate = TRUE,   # turns log-odds → OR
     conf.int     = TRUE)   # adds 95 % CI

logit_niv_abg <- glm(niv_proc ~ hypercap_on_abg, data = subset_data, family = binomial)
summary(logit_niv_abg)

tidy(logit_niv_abg,
     exponentiate = TRUE,   # turns log-odds → OR
     conf.int     = TRUE)   # adds 95 % CI

logit_death_abg <- glm(death_60d ~ hypercap_on_abg, data = subset_data, family = binomial)
summary(logit_death_abg)
tidy(logit_death_abg,
     exponentiate = TRUE,   # turns log-odds → OR
     conf.int     = TRUE)   # adds 95 % CI

logit_icd_abg <- glm(hypercap_resp_failure ~ hypercap_on_abg, data = subset_data, family = binomial)
summary(logit_icd_abg)
tidy(logit_icd_abg,
     exponentiate = TRUE,   # turns log-odds → OR
     conf.int     = TRUE)   # adds 95 % CI

```

Display the regression coefficients for the binary (hypercapnia yes/no) predictor logistic regressions

```{r}
modelsummary(
  list("Intubated" = logit_intubated_abg,
       "NIV"       = logit_niv_abg,
       "Death"     = logit_death_abg,
       "ICD Hyper" = logit_icd_abg),
  exponentiate = TRUE,
  conf_level   = 0.95,
  estimate     = "{estimate}",
  statistic    = "({conf.low}, {conf.high})",
  coef_omit    = "(Intercept)",
  gof_omit     = ".*",                      # drop all goodness-of-fit rows
  fmt          = 2,                         # 2 decimal places everywhere
  output       = "gt"
) |>
  gt::tab_header(title = "Odds Ratios for ABG Hypercapnia (>45 mmHg)'s association with...")
```

Unweighted VBG Group

```{r}
logit_intubated_vbg <- glm(imv_proc ~ hypercap_on_vbg, data = subset_data, family = binomial)
summary(logit_intubated_vbg)
tidy(logit_intubated_vbg,
     exponentiate = TRUE,   # turns log-odds → OR
     conf.int     = TRUE)   # adds 95 % CI

logit_niv_vbg <- glm(niv_proc ~ hypercap_on_vbg, data = subset_data, family = binomial)
summary(logit_niv_vbg)
tidy(logit_niv_vbg,
     exponentiate = TRUE,   # turns log-odds → OR
     conf.int     = TRUE)   # adds 95 % CI

logit_death_vbg <- glm(death_60d ~ hypercap_on_vbg, data = subset_data, family = binomial)
summary(logit_death_vbg)
tidy(logit_death_vbg,
     exponentiate = TRUE,   # turns log-odds → OR
     conf.int     = TRUE)   # adds 95 % CI

logit_icd_vbg <- glm(hypercap_resp_failure ~ hypercap_on_vbg, data = subset_data, family = binomial)
summary(logit_icd_vbg)
tidy(logit_icd_vbg,
     exponentiate = TRUE,   # turns log-odds → OR
      conf.int     = TRUE)   # adds 95 % CI
```

Display model coefficients for binary hypercapnia on VBG logistic regression

```{r}
modelsummary(
  list("Intubated" = logit_intubated_vbg,
       "NIV"       = logit_niv_vbg,
       "Death"     = logit_death_vbg,
       "ICD Hyper" = logit_icd_vbg),
  exponentiate = TRUE,
  conf_level   = 0.95,
  estimate     = "{estimate}",
  statistic    = "({conf.low}, {conf.high})",
  coef_omit    = "(Intercept)",
  gof_omit     = ".*",                      # drop all goodness-of-fit rows
  fmt          = 2,                         # 2 decimal places everywhere
  output       = "gt"
) |>
  gt::tab_header(title = "Odds Ratios for VBG Hypercapnia (>45 mmHg)'s association with...")
```

Calculated ABG from VBG Using Farkas equation - binary predictor

```{r}
subset_data <- subset_data %>%
  mutate(
    calc_abg = vbg_co2 - (0.22 * (93 - vbg_o2sat))
  )
subset_data <- subset_data %>%
  mutate(
    hypercapnia_calc = ifelse(calc_abg > 45, 1, 0)
  )
with(subset_data, table(hypercapnia_calc,niv_proc))
```

```{r}
logit_intubated_calc <- glm(imv_proc ~ hypercapnia_calc, data = subset_data, family = binomial)
summary(logit_intubated_calc)

tidy(logit_intubated_calc,
     exponentiate = TRUE,   # turns log-odds → OR
     conf.int     = TRUE)   # adds 95 % CI

logit_niv_calc <- glm(niv_proc ~ hypercapnia_calc, data = subset_data, family = binomial)
summary(logit_niv_calc)

tidy(logit_niv_calc,
     exponentiate = TRUE,   # turns log-odds → OR
     conf.int     = TRUE)   # adds 95 % CI

logit_death_calc <- glm(death_60d ~ hypercapnia_calc, data = subset_data, family = binomial)
summary(logit_death_calc)

tidy(logit_death_calc,
     exponentiate = TRUE,   # turns log-odds → OR
     conf.int     = TRUE)   # adds 95 % CI

logit_icd_calc <- glm(hypercap_resp_failure ~ hypercapnia_calc, data = subset_data, family = binomial)
summary(logit_icd_calc)

tidy(logit_icd_calc,
     exponentiate = TRUE,   # turns log-odds → OR
      conf.int     = TRUE)   # adds 95 % CI
```

Display regression coefficients for binary Farkas adjustment (hypercapnia yes/no as predictor)

```{r}
modelsummary(
  list("Intubated" = logit_intubated_calc,
       "NIV"       = logit_niv_calc,
       "Death"     = logit_death_calc,
       "ICD Hyper" = logit_icd_calc),
  exponentiate = TRUE,
  conf_level   = 0.95,
  estimate     = "{estimate}",
  statistic    = "({conf.low}, {conf.high})",
  coef_omit    = "(Intercept)",
  gof_omit     = ".*",                      # drop all goodness-of-fit rows
  fmt          = 2,                         # 2 decimal places everywhere
  output       = "gt"
) |>
  gt::tab_header(title = "Odds Ratios for Calculated Hypercapnia (>45 mmHg)'s association with...")
```

Odds Ratio Graph of all 3 simple, binary-predictor logistic regressions

```{r}
tidy_with_labels <- function(model, group_label, outcome_label) {
  tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
    filter(term == "hypercap_on_abg" | term == "hypercap_on_vbg" | term == "hypercapnia_calc") %>%
    mutate(
      group = group_label,
      outcome = outcome_label
    )
}

# --- ABG Models ---
abg_intub <- tidy_with_labels(glm(imv_proc ~ hypercap_on_abg, data = subset_data, family = binomial), "ABG", "Intubation")
abg_niv   <- tidy_with_labels(glm(niv_proc ~ hypercap_on_abg, data = subset_data, family = binomial), "ABG", "NIV")
abg_death <- tidy_with_labels(glm(death_60d ~ hypercap_on_abg, data = subset_data, family = binomial), "ABG", "Death")
abg_icd   <- tidy_with_labels(glm(hypercap_resp_failure ~ hypercap_on_abg, data = subset_data, family = binomial), "ABG", "ICD Code")

# --- VBG Models ---
vbg_intub <- tidy_with_labels(glm(imv_proc ~ hypercap_on_vbg, data = subset_data, family = binomial), "VBG", "Intubation")
vbg_niv   <- tidy_with_labels(glm(niv_proc ~ hypercap_on_vbg, data = subset_data, family = binomial), "VBG", "NIV")
vbg_death <- tidy_with_labels(glm(death_60d ~ hypercap_on_vbg, data = subset_data, family = binomial), "VBG", "Death")
vbg_icd   <- tidy_with_labels(glm(hypercap_resp_failure ~ hypercap_on_vbg, data = subset_data, family = binomial), "VBG", "ICD Code")

# --- Calculated ABG Models ---
calc_intub <- tidy_with_labels(glm(imv_proc ~ hypercapnia_calc, data = subset_data, family = binomial), "Calculated ABG", "Intubation")
calc_niv   <- tidy_with_labels(glm(niv_proc ~ hypercapnia_calc, data = subset_data, family = binomial), "Calculated ABG", "NIV")
calc_death <- tidy_with_labels(glm(death_60d ~ hypercapnia_calc, data = subset_data, family = binomial), "Calculated ABG", "Death")
calc_icd   <- tidy_with_labels(glm(hypercap_resp_failure ~ hypercapnia_calc, data = subset_data, family = binomial), "Calculated ABG", "ICD Code")

# --- Combine all model results ---
combined_or_df <- bind_rows(
  abg_intub, abg_niv, abg_death, abg_icd,
  vbg_intub, vbg_niv, vbg_death, vbg_icd,
  calc_intub, calc_niv, calc_death, calc_icd
)
```

**BL 7/16/2025** - Note[: new version below]{.underline}. For this, I changed the title, made the x-axis logarithmic (always logarithmic scale when the variable is a ratio, like an odds ratio or risk ratio), and added the clarification about denominators.

```{r}
ggplot(combined_or_df, aes(x = outcome, y = estimate, ymin = conf.low, ymax = conf.high, color = group)) +
  geom_pointrange(position = position_dodge(width = 0.5), size = 0.6) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "gray40") +
  coord_flip() +
  labs(
    title = "Unweighted, Unadjusted OR of Outcomes when Hypercapnia Present ABG, VBG, Farkas-VBG ",
    x = "Outcome",
    y = "Odds Ratio (95% CI)",
    color = "Group"
  ) +
  scale_y_log10(limits = c(-0.5, 15)) +  # optional log scale for better spacing
  theme_minimal(base_size = 10)

combined_or_df$group <- factor(combined_or_df$group,
  levels = c("ABG", "VBG", "Calculated ABG"))
```

```{r}
# ── prerequisites ───────────────────────────────────────────────────────────────

# order groups before plotting
combined_or_df$group <- factor(
  combined_or_df$group,
  levels = c("ABG", "VBG", "Calculated ABG")
)

# ── plot ────────────────────────────────────────────────────────────────────────
ggplot(
  combined_or_df,
  aes(
    x      = outcome,
    y      = estimate,
    ymin   = conf.low,
    ymax   = conf.high,
    color  = group
  )
) +
  geom_pointrange(
    position = position_dodge(width = 0.6),
    size     = 0.6
  ) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "grey40") +
  ## NOTE:  scale_y_log10 applies to the axis that *becomes horizontal* after coord_flip()
  scale_y_log10(
    breaks = c(0.25, 0.5, 1, 2, 4, 8, 16),
    limits = c(0.25, 16),
    labels = number_format(accuracy = 0.01)
  ) +
  coord_flip() +
  labs(
    title  = "Odds Ratio of Outcomes When Hypercapnia Present (ABG, VBG, Calc‑ABG)",
    x      = "Outcome",
    y      = "Odds Ratio (log scale, 95 % CI)",
    color  = "Blood‑gas type",
    caption = paste(
      "Odds ratios are computed *within* each blood‑gas cohort.",
      "Numerator = patients who received that blood‑gas and **had** hypercapnia;",
      "denominator = patients who received the same blood‑gas and **did not** have hypercapnia.",
      "Because the underlying cohorts differ (ABG, VBG, Calculated ABG),",
      "denominators are not identical across groups.",
      sep = "\n"
    )
  ) +
  theme_minimal(base_size = 10) +
  theme(plot.caption = element_text(hjust = 0))
```

**Restricted Cubic Spline Regressions**

```{r}
subset_data_clean <- subset_data %>%
  select(paco2, vbg_co2, imv_proc, niv_proc, death_60d, hypercap_resp_failure)

subset_data_clean <- subset_data_clean %>%
  filter(complete.cases(.))

dd <- datadist(subset_data_clean)
options(datadist = "dd")

```

Unweighted, Restricted Cubic Spline Regression - ABG by PaCO2

```{r}
fit_imv <- lrm(imv_proc ~ rcs(paco2, 4), data = subset_data_clean)
pred_imv <- as.data.frame(Predict(fit_imv, paco2, fun = plogis))

plot_imv <- ggplot(pred_imv, aes(x = paco2, y = yhat)) +
  geom_line(color = "blue", size = 1.2) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "blue", alpha = 0.2) +
  labs(title = "Probability of Intubation by PaCO₂",
       x = "PaCO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

fit_niv <- lrm(niv_proc ~ rcs(paco2, 4), data = subset_data_clean)
pred_niv <- as.data.frame(Predict(fit_niv, paco2, fun = plogis))

plot_niv <- ggplot(pred_niv, aes(x = paco2, y = yhat)) +
  geom_line(color = "green", size = 1.2) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "green", alpha = 0.2) +
  labs(title = "Probability of NIV by PaCO₂",
       x = "PaCO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

fit_death <- lrm(death_60d ~ rcs(paco2, 4), data = subset_data_clean)
pred_death <- as.data.frame(Predict(fit_death, paco2, fun = plogis))

plot_death <- ggplot(pred_death, aes(x = paco2, y = yhat)) +
  geom_line(color = "red", size = 1.2) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.2) +
  labs(title = "Probability of Death by PaCO₂",
       x = "PaCO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

fit_hcrf <- lrm(hypercap_resp_failure ~ rcs(paco2, 4), data = subset_data_clean)
pred_hcrf <- as.data.frame(Predict(fit_hcrf, paco2, fun = plogis))

plot_hcrf <- ggplot(pred_hcrf, aes(x = paco2, y = yhat)) +
  geom_line(color = "purple", size = 1.2) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "purple", alpha = 0.2) +
  labs(title = "Probability of Hypercapnic Respiratory Failure by PaCO₂",
       x = "PaCO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

(plot_imv | plot_niv) / (plot_death | plot_hcrf)

```

Unweighted, Restricted Cubic Spline - VBG

```{r}
subset_data_vbg <- subset_data %>%
  select(vbg_co2, imv_proc, niv_proc, death_60d, hypercap_resp_failure) %>%
  filter(!is.na(vbg_co2) & complete.cases(.))

dd <- datadist(subset_data_vbg)
options(datadist = "dd")

fit_imv_vbg <- lrm(imv_proc ~ rcs(vbg_co2, 4), data = subset_data_vbg)
fit_niv_vbg <- lrm(niv_proc ~ rcs(vbg_co2, 4), data = subset_data_vbg)
fit_death_vbg <- lrm(death_60d ~ rcs(vbg_co2, 4), data = subset_data_vbg)
fit_hcrf_vbg <- lrm(hypercap_resp_failure ~ rcs(vbg_co2, 4), data = subset_data_vbg)

pred_imv_vbg <- as.data.frame(Predict(fit_imv_vbg, vbg_co2, fun = plogis))
pred_niv_vbg <- as.data.frame(Predict(fit_niv_vbg, vbg_co2, fun = plogis))
pred_death_vbg <- as.data.frame(Predict(fit_death_vbg, vbg_co2, fun = plogis))
pred_hcrf_vbg <- as.data.frame(Predict(fit_hcrf_vbg, vbg_co2, fun = plogis))

plot_imv_vbg <- ggplot(pred_imv_vbg, aes(x = vbg_co2, y = yhat)) +
  geom_line(color = "blue") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "blue", alpha = 0.2) +
  labs(title = "IMV", x = "VBG CO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

plot_niv_vbg <- ggplot(pred_niv_vbg, aes(x = vbg_co2, y = yhat)) +
  geom_line(color = "green") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "green", alpha = 0.2) +
  labs(title = "NIV", x = "VBG CO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

plot_death_vbg <- ggplot(pred_death_vbg, aes(x = vbg_co2, y = yhat)) +
  geom_line(color = "red") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.2) +
  labs(title = "Death", x = "VBG CO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

plot_hcrf_vbg <- ggplot(pred_hcrf_vbg, aes(x = vbg_co2, y = yhat)) +
  geom_line(color = "purple") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "purple", alpha = 0.2) +
  labs(title = "Hypercapnic RF", x = "VBG CO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

((plot_imv_vbg | plot_niv_vbg) /
 (plot_death_vbg | plot_hcrf_vbg)) +
 plot_annotation(title = "Predicted Probability by VBG CO₂ (RCS Models)")

```

Unweighted, Restricted Cubic Spline Logistic Regressio - Calculated VBG to ABG (Farkas VBG Adjustment)

```{r}
subset_data_abg <- subset_data %>%
  select(calc_abg, imv_proc, niv_proc, death_60d, hypercap_resp_failure) %>%
  filter(!is.na(calc_abg) & complete.cases(.))

dd <- datadist(subset_data_abg)
options(datadist = "dd")

fit_imv_abg   <- lrm(imv_proc ~ rcs(calc_abg, 4), data = subset_data_abg)
fit_niv_abg   <- lrm(niv_proc ~ rcs(calc_abg, 4), data = subset_data_abg)
fit_death_abg  <- lrm(death_60d ~ rcs(calc_abg, 4), data = subset_data_abg)
fit_hcrf_abg   <- lrm(hypercap_resp_failure ~ rcs(calc_abg, 4), data = subset_data_abg)

pred_imv_abg   <- as.data.frame(Predict(fit_imv_abg, calc_abg, fun = plogis))
pred_niv_abg   <- as.data.frame(Predict(fit_niv_abg, calc_abg, fun = plogis))
pred_death_abg <- as.data.frame(Predict(fit_death_abg, calc_abg, fun = plogis))
pred_hcrf_abg  <- as.data.frame(Predict(fit_hcrf_abg, calc_abg, fun = plogis))

plot_imv_abg <- ggplot(pred_imv_abg, aes(x = calc_abg, y = yhat)) +
  geom_line(color = "blue") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "blue", alpha = 0.2) +
  labs(title = "IMV", x = "Calculated ABG CO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

plot_niv_abg <- ggplot(pred_niv_abg, aes(x = calc_abg, y = yhat)) +
  geom_line(color = "green") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "green", alpha = 0.2) +
  labs(title = "NIV", x = "Calculated ABG CO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

plot_death_abg <- ggplot(pred_death_abg, aes(x = calc_abg, y = yhat)) +
  geom_line(color = "red") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.2) +
  labs(title = "Death", x = "Calculated ABG CO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

plot_hcrf_abg <- ggplot(pred_hcrf_abg, aes(x = calc_abg, y = yhat)) +
  geom_line(color = "purple") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "purple", alpha = 0.2) +
  labs(title = "Hypercapnic RF", x = "Calculated ABG CO₂ (mmHg)", y = "Predicted Probability") +
  theme_minimal()

((plot_imv_abg | plot_niv_abg) /
 (plot_death_abg | plot_hcrf_abg)) +
plot_annotation(title = "Predicted Probability by Calculated ABG CO₂ (RCS Models)")
```

**Inverse Propensity Weighting**

IPW done using Gradient Boosting Methods (GBM) - a type of decision-tree based machine learning. "***Random forests and GBM are designed to automatically include relevant interactions for variables included in the model.*** As such, using a GBM to estimate the PS model, can reduce model misspecification, since ***the analyst is not required to identify relevant interactions or nonlinearities."*** from this citation: PMID: [39947224](https://pubmed.ncbi.nlm.nih.gov/39947224/)<https://pmc.ncbi.nlm.nih.gov/articles/PMC11825193/>

Current propensity score uses **age_at_encounter + sex + race_ethnicity** (remember - have to specify to use this as a factor variable) **+ curr_bmi + copd + asthma + osa + chf + acute_nmd + phtn + location (as a factor variable)**

Note: for all these, I suggested new GBM adjustments that accomplish the following:

1.  Smaller GBM & stopping rule → faster fit, avoids over‑fitting, lighter tails (which lead to extreme weights that are problematic).

2.  bal.tab() documents balance; aim is to adjust spec until standard mean difference (SMD) \< 0.1.

3.  Weight stabilization (divide by mean) mitigates a few huge weights. I also winsorized, which is a way to avoid very extreme weights (ie you set \<1st percentile to the 1st percentile value, and \>99th percentile to 99th percentile.

4.  Uses robust variance estimation (e.g. allows the variances to change by PaCO2) for IP‑weighted GLM; works with splines via rcs(). This is a bit nuanced but I think good to change even though it adds complexity

5.  Deterministic seed ensures result replication.

```{r}
# ── 1. fit GBM propensity model, ABG ───────────────────────────────────────────────
set.seed(42)

weight_model <- weightit(
  has_abg ~ age_at_encounter + sex + factor(race_ethnicity) + curr_bmi +
            copd + asthma + osa + chf + acute_nmd + phtn + factor(location) + temp_new + sbp + dbp + hr + spo2,
  data        = subset_data,
  method      = "gbm",
  estimand    = "ATE",
  missing.    = "ind",
  n.trees     = 3000,
  interaction.depth = 3,
  shrinkage   = 0.01,
  bag.fraction= 0.6,
  cv.folds    = 5,
  stop.method = "es.mean",
  n.cores     = parallel::detectCores()
)

# ── 2. Winsorise / stabilise weights (two‑sided) ─────────────────────────────
w <- weight_model$weights            # original GBM weights
w <- w / mean(w)                     # stabilise
cut <- quantile(w, c(0.01, 0.99), na.rm = TRUE)
w   <- pmin(pmax(w, cut[1]), cut[2]) # two‑tail Winsorisation
w <- w / mean(w)                     # re‑stabilise so E[w]=1

# overwrite inside the object and attach to data
weight_model$weights <- w
subset_data$w_abg    <- w

# ── 3. balance diagnostics (only raw vs. IPW) ────────────────────────────────
bal  <- bal.tab(weight_model, un = TRUE, m.threshold = 0.1)

love.plot(
  bal,
  var.order     = "unadjusted",
  sample.names  = c("Raw", "IPW")    # rename legend entries
)

# ── 4. survey design with the same weights ───────────────────────────────────
design <- svydesign(ids = ~1, weights = ~w_abg, data = subset_data)

# ── 5. outcome models (examples) ─────────────────────────────────────────────
fit_niv   <- svyglm(niv_proc   ~ has_abg, design = design, family = quasibinomial())
fit_imv   <- svyglm(imv_proc   ~ has_abg, design = design, family = quasibinomial())
fit_death <- svyglm(death_60d       ~ has_abg, design = design, family = quasibinomial())
fit_icd   <- svyglm(hypercap_resp_failure ~ has_abg, design = design, family = quasibinomial())

# quick effect estimates
lapply(list(IMV = fit_imv, NIV = fit_niv, Death = fit_death, ICD = fit_icd), function(m) {
  c(OR  = exp(coef(m)[2]),
    LCL = exp(confint(m)[2,1]),
    UCL = exp(confint(m)[2,2]))
})


```

**Inverse Propensity-Weighted Logistic Regressions with CO2 predictor represented as a restricted cubic spline.**

ABG - IPW with age_at_encounter + sex + race_ethnicity (factor) + curr_bmi + copd + asthma + osa + chf + acute_nmd + phtn +location (factor) as predictors.

**BL**: added a new new version

```{r}
# set.seed(42)  # reproducible GBM fit
# 
# # ── 1. inverse‑probability weights for receiving an ABG ───────────────────────
# 
# # done in the last block, so not needed
# 

# ── 2. analysis sample: rows with a measured PaCO₂ ────────────────────────────
subset_data_abg <- subset_data %>%
  filter(!is.na(paco2)) %>%                    # implies has_abg == 1
  select(paco2, imv_proc, niv_proc, death_60d,
         hypercap_resp_failure, w_abg) %>%
  filter(complete.cases(.))


# ── 3. weighted logistic spline models with robust SEs ───────────────────────
dd <- datadist(subset_data_abg); options(datadist = "dd")

fitfun <- function(formula)
  svyglm(
    formula,
    design = svydesign(ids = ~1, weights = ~w_abg, data = subset_data_abg),
    family = quasibinomial()
  )

fit_imv   <- fitfun(imv_proc              ~ rcs(paco2, 4))
fit_niv   <- fitfun(niv_proc              ~ rcs(paco2, 4))
fit_death <- fitfun(death_60d                  ~ rcs(paco2, 4))
fit_hcrf  <- fitfun(hypercap_resp_failure ~ rcs(paco2, 4))

# ── 4. prediction helper ─────────────────────────────────────────────────────
mkpred <- function(fit, data_ref) {
  # 1. Grid of PaCO₂ values
  newd <- data.frame(
    paco2 = seq(min(data_ref$paco2, na.rm = TRUE),
                max(data_ref$paco2, na.rm = TRUE),
                length.out = 200)
  )

  # 2. Design (model) matrix for the new data
  mm <- model.matrix(delete.response(terms(fit)),  # drop outcome
                     data = newd)

  # 3. Linear predictor and its standard error
  eta  <- mm %*% coef(fit)                        # β'x
  vcov <- vcov(fit)                               # robust VCOV from svyglm
  se   <- sqrt(rowSums((mm %*% vcov) * mm))       # √diag(X Σ Xᵀ)

  # 4. Transform to probability scale
  transform(
    newd,
    yhat  = plogis(eta),
    lower = plogis(eta - 1.96 * se),
    upper = plogis(eta + 1.96 * se)
  )
}

pred_imv   <- mkpred(fit_imv,   subset_data_abg)
pred_niv   <- mkpred(fit_niv,   subset_data_abg)
pred_death <- mkpred(fit_death, subset_data_abg)
pred_hcrf  <- mkpred(fit_hcrf,  subset_data_abg)

# ── 5. plotting ──────────────────────────────────────────────────────────────
xlab <- expression(paste("ABG CO"[2], " (mmHg)"))

plt <- function(dat, title)
  ggplot(dat, aes(paco2, yhat)) +
    geom_line() +
    geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
    scale_y_continuous(limits = c(0, 1), labels = percent_format(accuracy = 1)) +
    labs(title = title, x = xlab, y = "Predicted probability") +
    theme_minimal()

(patchwork::wrap_plots(
    plt(pred_imv,   "IMV"),
    plt(pred_niv,   "NIV"),
    plt(pred_death, "Death"),
    plt(pred_hcrf,  "Hypercapnic RF"),
    ncol = 2
  )
) +
  plot_annotation(
    title = expression(
      paste("Propensity‑weighted predicted probability by ABG CO"[2],
            " (restricted cubic spline)")
    )
)
```

VBG

```{r}
# ──────────────────────────────────────────────────────────────────────────────
#  Inverse‑propensity weighting & outcome modelling for **VBG** cohort
#    – mirrored 1‑to‑1 to the validated ABG workflow
# ──────────────────────────────────────────────────────────────────────────────

set.seed(42)   # identical seed for direct comparability

# 1. Inverse‑probability weights for receiving a VBG ---------------------------

w_vbg <- weightit(
  has_vbg ~ age_at_encounter + sex + factor(race_ethnicity) + curr_bmi +
            copd + asthma + osa + chf + acute_nmd + phtn + factor(location),
  data        = subset_data,
  method      = "gbm",
  estimand    = "ATE",
  missing.    = "ind",
  n.trees     = 3000,
  interaction.depth = 3,
  shrinkage   = 0.01,
  bag.fraction= 0.6,
  cv.folds    = 5,
  stop.method = "es.mean",
  n.cores     = parallel::detectCores()
)

# ── 2. Winsorise / stabilise weights (two‑sided) ─────────────────────────────
w <- w_vbg$weights            # original GBM weights
w <- w / mean(w)                     # stabilise
cut <- quantile(w, c(0.01, 0.99), na.rm = TRUE)
w   <- pmin(pmax(w, cut[1]), cut[2]) # two‑tail Winsorisation
w <- w / mean(w)                     # re‑stabilise so E[w]=1

# overwrite inside the object and attach to data
w_vbg$weights <- w
subset_data$w_vbg    <- w

bal.tab(w_vbg, un = TRUE, m.threshold = 0.1)      # inspect balance

# 2. Analysis sample: rows with measured VBG CO₂ --------------------------------
subset_data_vbg <- subset_data %>%
  filter(!is.na(vbg_co2)) %>%                     # implies has_vbg == 1
  select(vbg_co2, imv_proc, niv_proc, death_60d, 
         hypercap_resp_failure, w_vbg) %>%
  filter(complete.cases(.))

# 3. Weighted logistic spline models with robust SEs ---------------------------
dd <- datadist(subset_data_vbg); options(datadist = "dd")

fitfun <- function(formula)
  svyglm(
    formula,
    design = svydesign(ids = ~1, weights = ~w_vbg, data = subset_data_vbg),
    family = quasibinomial()
  )

fit_imv_vbg   <- fitfun(imv_proc              ~ rcs(vbg_co2, 4))
fit_niv_vbg   <- fitfun(niv_proc              ~ rcs(vbg_co2, 4))
fit_death_vbg <- fitfun(death_60d                 ~ rcs(vbg_co2, 4))
fit_hcrf_vbg  <- fitfun(hypercap_resp_failure ~ rcs(vbg_co2, 4))

# 4. Prediction helper (robust to predict() quirks) ----------------------------
mkpred <- function(fit, data_ref) {
  newd <- data.frame(
    vbg_co2 = seq(min(data_ref$vbg_co2, na.rm = TRUE),
                  max(data_ref$vbg_co2, na.rm = TRUE),
                  length.out = 200)
  )
  mm   <- model.matrix(delete.response(terms(fit)), newd)
  eta  <- mm %*% coef(fit)
  vcov <- vcov(fit)
  se   <- sqrt(rowSums((mm %*% vcov) * mm))
  transform(
    newd,
    yhat  = plogis(eta),
    lower = plogis(eta - 1.96 * se),
    upper = plogis(eta + 1.96 * se)
  )
}

pred_imv_vbg   <- mkpred(fit_imv_vbg,   subset_data_vbg)
pred_niv_vbg   <- mkpred(fit_niv_vbg,   subset_data_vbg)
pred_death_vbg <- mkpred(fit_death_vbg, subset_data_vbg)
pred_hcrf_vbg  <- mkpred(fit_hcrf_vbg,  subset_data_vbg)

# 5. Plotting -------------------------------------------------------------------
xlab <- expression(paste("VBG CO"[2], " (mmHg)"))

plt <- function(dat, title)
  ggplot(dat, aes(vbg_co2, yhat)) +
    geom_line() +
    geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
    scale_y_continuous(limits = c(0, 1), labels = percent_format(accuracy = 1))  +
    labs(title = title, x = xlab, y = "Predicted probability") +
    theme_minimal()

(patchwork::wrap_plots(
    plt(pred_imv_vbg,   "IMV"),
    plt(pred_niv_vbg,   "NIV"),
    plt(pred_death_vbg, "Death"),
    plt(pred_hcrf_vbg,  "Hypercapnic RF"),
    ncol = 2
  )
) +
  plot_annotation(
    title = expression(
      paste("Propensity‑weighted predicted probability by VBG CO"[2],
            " (restricted cubic spline)")
    )
)
```

Calculated VBG to ABG / Farkas

New version:

```{r}
# ──────────────────────────────────────────────────────────────────────────────
#  Propensity‑weighted spline models for **Calculated ABG CO₂**
#    (weights still derive from propensity to receive a VBG)
# ──────────────────────────────────────────────────────────────────────────────

# ── 1. define the new treatment variable --------------------------------------
subset_data <- subset_data %>%
  mutate(
    has_vbg_co2_o2_sat = if_else(
      !is.na(vbg_co2)  & vbg_co2  != 0 &
      !is.na(vbg_o2sat) & vbg_o2sat != 0,
      1, 0
    )
  )

# quick sanity check
# table(subset_data$has_vbg_co2_o2_sat, useNA = "ifany")

# ── 2. fit the GBM propensity model -------------------------------------------
set.seed(42)

w_vbg_calc <- weightit(
  has_vbg_co2_o2_sat ~ age_at_encounter + sex + factor(race_ethnicity) +
                       curr_bmi + copd + asthma + osa + chf +
                       acute_nmd + phtn + factor(location),
  data        = subset_data,
  method      = "gbm",
  estimand    = "ATE",
  missing.    = "ind",
  n.trees     = 3000,
  interaction.depth = 3,
  shrinkage   = 0.01,
  bag.fraction= 0.6,
  cv.folds    = 5,
  stop.method = "es.mean",
  n.cores     = detectCores()
)

# ── 3. (optional) stabilise + two‑sided Winsorisation --------------------------
w <- w_vbg_calc$weights
w <- w / mean(w)

cut <- quantile(w, c(0.01, 0.99), na.rm = TRUE)
w   <- pmin(pmax(w, cut[1]), cut[2])
w   <- w / mean(w)

subset_data$w_vbg_calc <- w          # attach to data frame
w_vbg_calc$weights     <- w          # overwrite inside object for diagnostics



bal.tab(w_vbg_calc, un = TRUE, m.threshold = 0.1)   # inspect balance

# 2. Analysis sample: rows with a calculated ABG CO₂ ---------------------------
subset_data_calc <- subset_data %>%
  filter(!is.na(calc_abg)) %>%                       # implies has_vbg == 1
  select(calc_abg, imv_proc, niv_proc, death_60d,
         hypercap_resp_failure, w_vbg_calc) %>%
  filter(complete.cases(.)) 

# 3. Weighted logistic spline models with robust SEs ---------------------------
dd <- datadist(subset_data_calc); options(datadist = "dd")

fitfun <- function(formula)
  svyglm(
    formula,
    design = svydesign(ids = ~1, weights = ~w_vbg_calc, data = subset_data_calc),
    family = quasibinomial()
  )

fit_imv_calc   <- fitfun(imv_proc              ~ rcs(calc_abg, 4))
fit_niv_calc   <- fitfun(niv_proc              ~ rcs(calc_abg, 4))
fit_death_calc <- fitfun(death_60d                  ~ rcs(calc_abg, 4))
fit_hcrf_calc  <- fitfun(hypercap_resp_failure ~ rcs(calc_abg, 4))

# 4. Prediction helper ---------------------------------------------------------
mkpred <- function(fit, data_ref) {
  newd <- data.frame(
    calc_abg = seq(min(data_ref$calc_abg, na.rm = TRUE),
                   max(data_ref$calc_abg, na.rm = TRUE),
                   length.out = 200)
  )
  mm   <- model.matrix(delete.response(terms(fit)), newd)
  eta  <- mm %*% coef(fit)
  vcov <- vcov(fit)
  se   <- sqrt(rowSums((mm %*% vcov) * mm))
  transform(
    newd,
    yhat  = plogis(eta),
    lower = plogis(eta - 1.96 * se),
    upper = plogis(eta + 1.96 * se)
  )
}

pred_imv_calc   <- mkpred(fit_imv_calc,   subset_data_calc)
pred_niv_calc   <- mkpred(fit_niv_calc,   subset_data_calc)
pred_death_calc <- mkpred(fit_death_calc, subset_data_calc)
pred_hcrf_calc  <- mkpred(fit_hcrf_calc,  subset_data_calc)

# 5. Plotting -------------------------------------------------------------------
xlab <- expression(paste("Calculated ABG CO"[2], " (mmHg)"))

plt <- function(dat, title)
  ggplot(dat, aes(calc_abg, yhat)) +
    geom_line() +
    geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
    scale_y_continuous(limits = c(0, 1), labels = percent_format(accuracy = 1))  +
    labs(title = title, x = xlab, y = "Predicted probability") +
    theme_minimal()

(patchwork::wrap_plots(
    plt(pred_imv_calc,   "IMV"),
    plt(pred_niv_calc,   "NIV"),
    plt(pred_death_calc, "Death"),
    plt(pred_hcrf_calc,  "Hypercapnic RF"),
    ncol = 2
  )
) +
  plot_annotation(
    title = expression(
      paste("Propensity‑weighted predicted probability by Calculated ABG CO"[2],
            " (restricted cubic spline)")
    )
)
```

**New** weighted binary regression figures.

```{r}
# ──────────────────────────────────────────────────────────────────────────────
#  IP‑weighted odds‑ratio plot (ABG, VBG, Calculated‑ABG)
#    – exact analogue of the un‑weighted figure
# ──────────────────────────────────────────────────────────────────────────────

# weights already attached earlier:
#   • w_abg         – propensity for *ABG*   (column in subset_data)
#   • w_vbg         – propensity for *VBG*   (column in subset_data)
#   • w_vbg_calc    – same weights, used for calculated ABG CO₂

# 1. helper to fit an IP‑weighted GLM and return tidy OR -----------------------
tidy_ipw <- function(data, outcome, exposure, weight_var,
                     group_label, outcome_label) {
  des <- svydesign(ids = ~1, weights = as.formula(paste0("~", weight_var)),
                   data = data)
  mod <- svyglm(
    as.formula(paste0(outcome, " ~ ", exposure)),
    design = des,
    family = quasibinomial()
  )

  tidy(mod, exponentiate = TRUE, conf.int = TRUE) %>%
    filter(term == exposure) %>%                # keep the exposure row
    mutate(group = group_label, outcome = outcome_label)
}

# 2. cohort‑specific data frames ----------------------------------------------
abg_df   <- subset_data %>% filter(has_abg == 1)
vbg_df   <- subset_data %>% filter(has_vbg == 1)
calc_df  <- subset_data %>% filter(!is.na(calc_abg))   # implies VBG present

# 3. fit models & collect estimates -------------------------------------------
ipw_estimates <- bind_rows(
  # ABG
  tidy_ipw(abg_df,  "imv_proc",              "hypercap_on_abg", "w_abg",      "ABG",           "Intubation"),
  tidy_ipw(abg_df,  "niv_proc",              "hypercap_on_abg", "w_abg",      "ABG",           "NIV"),
  tidy_ipw(abg_df,  "death_60d",                  "hypercap_on_abg", "w_abg",      "ABG",           "Death"),
  tidy_ipw(abg_df,  "hypercap_resp_failure", "hypercap_on_abg", "w_abg",      "ABG",           "ICD Code"),

  # VBG
  tidy_ipw(vbg_df,  "imv_proc",              "hypercap_on_vbg", "w_vbg",      "VBG",           "Intubation"),
  tidy_ipw(vbg_df,  "niv_proc",              "hypercap_on_vbg", "w_vbg",      "VBG",           "NIV"),
  tidy_ipw(vbg_df,  "death_60d",                  "hypercap_on_vbg", "w_vbg",      "VBG",           "Death"),
  tidy_ipw(vbg_df,  "hypercap_resp_failure", "hypercap_on_vbg", "w_vbg",      "VBG",           "ICD Code"),

  # Calculated ABG
  tidy_ipw(calc_df, "imv_proc",              "hypercapnia_calc","w_vbg_calc", "Calculated ABG","Intubation"),
  tidy_ipw(calc_df, "niv_proc",              "hypercapnia_calc","w_vbg_calc", "Calculated ABG","NIV"),
  tidy_ipw(calc_df, "death_60d",                  "hypercapnia_calc","w_vbg_calc", "Calculated ABG","Death"),
  tidy_ipw(calc_df, "hypercap_resp_failure", "hypercapnia_calc","w_vbg_calc", "Calculated ABG","ICD Code")
)

# 4. plotting ------------------------------------------------------------------
ipw_estimates$group <- factor(
  ipw_estimates$group,
  levels = c("ABG", "VBG", "Calculated ABG")
)

ggplot(
  ipw_estimates,
  aes(
    x     = outcome,
    y     = estimate,
    ymin  = conf.low,
    ymax  = conf.high,
    color = group
  )
) +
  geom_pointrange(position = position_dodge(width = 0.6), size = 0.6) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "grey40") +
  scale_y_log10(
    breaks = c(0.25, 0.5, 1, 2, 4, 8, 16),
    limits = c(0.25, 16),
    labels = number_format(accuracy = 0.01)
  ) +
  coord_flip() +
  labs(
    title  = "IP‑Weighted Odds Ratio of Outcomes When Hypercapnia Present",
    x      = "Outcome",
    y      = "Odds Ratio (log scale, 95 % CI)",
    color  = "Blood‑gas type",
    caption = paste(
      "Inverse‑probability weights adjust for covariates associated with receiving each blood‑gas.",
      "Models are fitted within their respective cohorts:",
      "ABG (weights = w_abg), VBG (w_vbg), Calculated ABG (w_vbg_calc).",
      "Numerator = hypercapnic; denominator = normocapnic within cohort.",
      sep = "\n"
    )
  ) +
  theme_minimal(base_size = 10) +
  theme(plot.caption = element_text(hjust = 0))
```

------------------------------------------------------------------------

Below is still in progress trying to do diagnostics for propensity scores - will keep working on it

```{r}


# 1.  Propensity model & IPTW -----------------------------------------
library(WeightIt)
w_vbg_calc <- weightit(
  has_vbg_co2_o2_sat ~ age_at_encounter + sex + factor(race_ethnicity) +
                       curr_bmi + copd + asthma + osa + chf +
                       acute_nmd + phtn + factor(location),
  data        = subset_data,
  method      = "gbm",
  estimand    = "ATE",
  missing.    = "ind",
  n.trees     = 3000,
  interaction.depth = 3,
  shrinkage   = 0.01,
  bag.fraction= 0.6,
  cv.folds    = 5,
  stop.method = "es.mean",
  n.cores     = detectCores()
)

# 2.  Diagnostics ------------------------------------------------------
library(cobalt)

bal <- bal.tab(
  w_vbg_calc,
  un          = TRUE,
  m.threshold = 0.05,
  binary      = "std"     # <— standardize binary covariates
)

love.plot(
  bal,
  abs          = TRUE,
  var.order    = "unadjusted",
  thresholds   = c(m = 0.05),
  sample.names = c("Raw","IPW")
)

ps_df <- data.frame(ps = w_vbg_calc$ps,
                    treat = factor(subset_data$has_vbg_co2_o2_sat))
lattice::histogram(~ ps | treat, data = ps_df)

ps_df <- data.frame(
  ps    = w_vbg_calc$ps,                         # from WeightIt (gbm)
  treat = factor(subset_data$has_vbg_co2_o2_sat)
)

lattice::histogram(~ ps | treat, data = ps_df)

# 3.  Outcome analysis -------------------------------------------------
library(survey)
dsgn <- svydesign(ids = ~1, weights = ~w_vbg_calc, data = subset_data)
fit_imv   <- svyglm(imv_proc              ~ has_vbg_co2_o2_sat, design = dsgn, family = quasibinomial())
fit_niv   <- svyglm(niv_proc              ~ has_vbg_co2_o2_sat, design = dsgn, family = quasibinomial())
fit_death <- svyglm(death_60d             ~ has_vbg_co2_o2_sat, design = dsgn, family = quasibinomial())
fit_hcrf  <- svyglm(hypercap_resp_failure ~ has_vbg_co2_o2_sat, design = dsgn, family = quasibinomial())

summary(fit_imv)
summary(fit_niv)
summary(fit_death)
summary(fit_hcrf)


# Sensitivity 
# ... code to build m_pairs, md_pairs, and Y_imv (as above) ...
#library(sensitivitymw)
#senmw(Y_imv, gamma = 1.5, method = "p")

# 4.  Sensitivity for matched pairs (IMV)------------------------------------------------------
#library(sensitivitymw)
#senmw(outcome, treat, data = dat, gamma = 1.5)

```
